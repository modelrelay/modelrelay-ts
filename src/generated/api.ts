/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/schemas/workflow_v0.schema.json": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get JSON Schema for workflow.v0
         * @description Returns the canonical JSON Schema (draft-07) for `workflow.v0`.
         */
        get: operations["getWorkflowV0Schema"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/schemas/run_event_v0.schema.json": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get JSON Schema for run_event.v0
         * @description Returns the canonical JSON Schema (draft-07) for `run_event.v0` (workflow run history events).
         */
        get: operations["getRunEventV0Schema"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/auth/register": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Register a new owner account */
        post: operations["registerOwner"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/auth/login": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Exchange credentials for tokens */
        post: operations["login"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/auth/refresh": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Refresh an access token */
        post: operations["refreshToken"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/auth/logout": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Revoke a refresh token */
        post: operations["logout"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/auth/me": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Fetch the authenticated user profile */
        get: operations["getAuthenticatedUser"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/auth/customer-token": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Mint a customer-scoped bearer token
         * @description Used by trusted backends to mint short-lived customer-scoped bearer tokens
         *     for data-plane access (/responses, /runs). Requires a secret API key (mr_sk_*).
         *     The customer must already exist; use /customers endpoints to create customers first.
         */
        post: operations["mintCustomerToken"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/auth/device/start": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Start a device authorization session
         * @description Starts an OAuth 2.0 device authorization session so constrained clients (TUIs)
         *     can obtain a customer-scoped bearer token without running a local web server.
         *     Requires a project-scoped API key (publishable or secret).
         */
        post: operations["startDeviceAuthorization"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/auth/device/token": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Poll a device authorization session
         * @description Polls a device authorization session by `device_code`. Returns a customer-scoped bearer token
         *     once the user completes authorization in the browser.
         */
        post: operations["pollDeviceToken"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/auth/oidc/exchange": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Exchange an OIDC id_token for a customer bearer token
         * @description Verifies a provided OIDC `id_token` using the project's configured OIDC settings,
         *     resolves (provider, subject) to a customer via customer_identities, and returns
         *     a short-lived customer-scoped bearer token for data-plane access.
         */
        post: operations["exchangeOidcToken"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/customers/claim": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Link an end-user identity to a customer by email
         * @description Used when a customer subscribes via Stripe Checkout (email only) and later authenticates to the app.
         *     Links (provider, subject) to the existing customer record found by email.
         */
        post: operations["claimCustomer"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/customers/me": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get the authenticated customer
         * @description Returns the current customer associated with the provided customer-scoped bearer token.
         *     Includes the customer's tier and allowed models.
         */
        get: operations["getCustomerMe"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/customers/me/usage": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get the authenticated customer's usage
         * @description Returns the current billing period usage summary for the customer.
         *     Includes spend limit, current spend, remaining budget, and usage state.
         */
        get: operations["getCustomerMeUsage"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/models": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List active models
         * @description Returns all active models with rich metadata for building model selectors.
         */
        get: operations["listModels"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/billing/webhooks": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Stripe webhook receiver
         * @description Accepts subscription lifecycle events from Stripe.
         */
        post: operations["handleBillingWebhook"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/projects": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List projects for the authenticated owner */
        get: operations["listProjects"];
        put?: never;
        /** Create a project */
        post: operations["createProject"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/projects/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                id: components["parameters"]["ProjectID"];
            };
            cookie?: never;
        };
        /** Get a project */
        get: operations["getProject"];
        /** Update a project */
        put: operations["updateProject"];
        post?: never;
        /** Delete a project */
        delete: operations["deleteProject"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/projects/{id}/tiers": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                id: components["parameters"]["ProjectID"];
            };
            cookie?: never;
        };
        /** List tiers for a project */
        get: operations["listProjectTiers"];
        put?: never;
        /** Create a tier */
        post: operations["createTier"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/projects/{id}/tiers/{tier_id}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                id: components["parameters"]["ProjectID"];
                tier_id: string;
            };
            cookie?: never;
        };
        get?: never;
        /** Update a tier */
        put: operations["updateTier"];
        post?: never;
        /** Delete a tier */
        delete: operations["deleteTier"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/projects/{id}/customers": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                id: components["parameters"]["ProjectID"];
            };
            cookie?: never;
        };
        /** List customers for a project */
        get: operations["listProjectCustomers"];
        put?: never;
        /** Create a customer */
        post: operations["createCustomer"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/projects/{id}/customers/{customer_id}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                id: components["parameters"]["ProjectID"];
                customer_id: string;
            };
            cookie?: never;
        };
        get?: never;
        /** Update a customer */
        put: operations["updateCustomer"];
        post?: never;
        /** Delete a customer */
        delete: operations["deleteCustomer"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/responses": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Create a response via the provider-agnostic API */
        post: operations["createResponse"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/responses:batch": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Create multiple responses concurrently (batch) */
        post: operations["createResponsesBatch"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/plugins/load": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Load a plugin from GitHub (server-side)
         * @description Fetches PLUGIN.md, commands/*.md, and agents/*.md from a GitHub URL and returns the normalized plugin representation. Auth matches /runs (API key or customer bearer token). Session owner tokens from /auth/login are not accepted.
         */
        post: operations["pluginsLoad"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/plugins/runs": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Run a plugin command via workflows
         * @description Loads a plugin from GitHub, converts it to workflow.v0 via an LLM, and starts a run via /runs. Client-side tool execution uses the existing /runs/{run_id}/pending-tools and /runs/{run_id}/tool-results endpoints.
         */
        post: operations["pluginsRun"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/runs": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Start a workflow run (workflow.v0)
         * @description Starts a run for a `workflow.v0` spec and returns a `run_id`. Auth matches `/responses` (API key or frontend bearer token). Session owner tokens from `/auth/login` are not accepted.
         */
        post: operations["createRun"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/runs/{run_id}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                run_id: string;
            };
            cookie?: never;
        };
        /**
         * Get a derived run snapshot
         * @description Returns a derived snapshot state for the run (folded from event history + artifacts), including outputs and an aggregated cost summary when available.
         */
        get: operations["getRun"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/runs/{run_id}/events": {
        parameters: {
            query?: {
                /** @description Returns events where `seq > after_seq`. */
                after_seq?: number;
                /** @description When false, returns currently available events then closes. */
                wait?: boolean;
                /** @description Maximum number of events to send before closing. */
                limit?: number;
            };
            header?: never;
            path: {
                run_id: string;
            };
            cookie?: never;
        };
        /**
         * Stream run events (append-only)
         * @description Streams an append-only, totally ordered history for the run. The wire format is negotiated via `Accept`: NDJSON (`application/x-ndjson`) or Server-Sent Events (`text/event-stream`). Each line/event is a `run_event.v0` envelope; see `/schemas/run_event_v0.schema.json` for the canonical schema.
         */
        get: operations["streamRunEvents"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        AuthTokens: {
            access_token?: string;
            refresh_token?: string;
            /** Format: date-time */
            expires_at?: string;
        };
        AuthResponse: {
            user?: components["schemas"]["User"];
            tokens?: components["schemas"]["AuthTokens"];
            access_token?: string;
            refresh_token?: string;
        };
        User: {
            /** Format: uuid */
            id?: string;
            /** Format: email */
            email?: string;
            /** Format: uuid */
            project_id?: string;
        };
        Project: {
            /** Format: uuid */
            id?: string;
            /** Format: uuid */
            owner_id?: string;
            name?: string;
            description?: string;
            /** Format: uuid */
            customer_auto_provision_tier_id?: string;
            customer_oauth_providers?: ("github" | "google")[];
            oidc_enabled?: boolean;
            oidc_issuer?: string;
            oidc_audiences?: string[];
            oidc_jwks_url?: string;
            oidc_subject_claim?: string;
            /** Format: date-time */
            created_at?: string;
            /** Format: date-time */
            updated_at?: string;
        };
        /**
         * @description Billing interval for a tier.
         * @enum {string}
         */
        PriceInterval: "month" | "year";
        TierModel: {
            /** Format: uuid */
            id: string;
            /** Format: uuid */
            tier_id: string;
            model_id: components["schemas"]["ModelId"];
            /** @description Human-friendly model name resolved from pricing (e.g., 'GPT-4o Mini') */
            model_display_name: string;
            /** @description Human-friendly description of what the model is good at */
            description: string;
            /** @description Workflow-critical capability flags for the model */
            capabilities: components["schemas"]["ModelCapability"][];
            /**
             * Format: int32
             * @description Maximum supported context window in tokens (if known)
             */
            context_window: number;
            /**
             * Format: int32
             * @description Maximum supported output tokens (if known)
             */
            max_output_tokens: number;
            /** @description Whether the model is deprecated */
            deprecated: boolean;
            /**
             * Format: uint64
             * @description Input token price in cents per million (e.g., 300 = $3.00/1M tokens)
             */
            input_price_per_million_cents: number;
            /**
             * Format: uint64
             * @description Output token price in cents per million (e.g., 1500 = $15.00/1M tokens)
             */
            output_price_per_million_cents: number;
            /** @description Whether this is the default model for the tier */
            is_default: boolean;
            /** Format: date-time */
            created_at: string;
            /** Format: date-time */
            updated_at: string;
        };
        TierModelCreate: {
            model_id: components["schemas"]["ModelId"];
            /** Format: uint64 */
            input_price_per_million_cents: number;
            /** Format: uint64 */
            output_price_per_million_cents: number;
            /** @default false */
            is_default: boolean;
        };
        Tier: {
            /** Format: uuid */
            id?: string;
            /** Format: uuid */
            project_id?: string;
            tier_code?: components["schemas"]["TierCode"];
            /** @description Human-readable tier name */
            display_name?: string;
            /**
             * Format: uint64
             * @description Monthly spend limit in cents (e.g., 2000 = $20/month). Must be non-negative.
             */
            spend_limit_cents?: number;
            models?: components["schemas"]["TierModel"][];
            /** @description Stripe price ID for this tier */
            stripe_price_id?: string;
            /**
             * Format: uint64
             * @description Subscription price amount in cents
             */
            price_amount_cents?: number;
            /** @description Currency code for the price (e.g., 'usd') */
            price_currency?: string;
            price_interval?: components["schemas"]["PriceInterval"];
            /**
             * Format: uint32
             * @description Number of trial days for new subscriptions
             */
            trial_days?: number;
            /** Format: date-time */
            created_at?: string;
            /** Format: date-time */
            updated_at?: string;
        };
        TierCreate: {
            tier_code: components["schemas"]["TierCode"];
            /** @description Human-readable tier name */
            display_name: string;
            /**
             * Format: uint64
             * @description Monthly spend limit in cents (e.g., 2000 = $20/month). Must be non-negative.
             */
            spend_limit_cents: number;
            models: components["schemas"]["TierModelCreate"][];
            /**
             * Format: uint64
             * @description Subscription price amount in cents (paid tiers)
             */
            price_amount_cents?: number;
            price_interval?: components["schemas"]["PriceInterval"];
            /**
             * Format: uint32
             * @description Number of trial days for new subscriptions (paid tiers)
             */
            trial_days?: number;
        };
        TierUpdate: {
            tier_code: components["schemas"]["TierCode"];
            /** @description Human-readable tier name */
            display_name: string;
            /**
             * Format: uint64
             * @description Monthly spend limit in cents (e.g., 2000 = $20/month). Must be non-negative.
             */
            spend_limit_cents: number;
            models?: components["schemas"]["TierModelCreate"][];
            /**
             * Format: uint64
             * @description Subscription price amount in cents (paid tiers)
             */
            price_amount_cents?: number;
            price_interval?: components["schemas"]["PriceInterval"];
            /**
             * Format: uint32
             * @description Number of trial days for new subscriptions (paid tiers)
             */
            trial_days?: number;
        };
        Customer: {
            /** Format: uuid */
            id?: string;
            /** Format: uuid */
            project_id?: string;
            /** Format: uuid */
            tier_id?: string;
            tier_code?: components["schemas"]["TierCode"];
            /** @description External customer identifier from your system */
            external_id?: string;
            /**
             * Format: email
             * @description Customer email address
             */
            email?: string;
            metadata?: {
                [key: string]: unknown;
            };
            /** @description Stripe customer ID */
            stripe_customer_id?: string;
            /** @description Stripe subscription ID */
            stripe_subscription_id?: string;
            /** @description Subscription status (active, past_due, canceled, etc.) */
            subscription_status?: string;
            /**
             * Format: date-time
             * @description Start of the current billing period
             */
            current_period_start?: string;
            /**
             * Format: date-time
             * @description End of the current billing period
             */
            current_period_end?: string;
            /** Format: date-time */
            created_at?: string;
            /** Format: date-time */
            updated_at?: string;
        };
        CustomerMe: components["schemas"]["Customer"] & {
            tier: components["schemas"]["Tier"];
        };
        CustomerMeResponse: {
            customer: components["schemas"]["CustomerMe"];
        };
        /** @description Usage summary for the current billing period. */
        CustomerMeUsage: {
            /**
             * Format: date-time
             * @description Start of the current billing window
             */
            window_start: string;
            /**
             * Format: date-time
             * @description End of the current billing window
             */
            window_end: string;
            /**
             * Format: int64
             * @description Monthly spend limit from tier in cents (0 = unlimited)
             */
            spend_limit_cents: number;
            /**
             * Format: int64
             * @description Amount spent in current billing window in cents
             */
            current_spend_cents: number;
            /**
             * Format: int64
             * @description Remaining spend budget in cents (0 for unlimited tiers)
             */
            remaining_cents: number;
            /**
             * Format: float
             * @description Percentage of spend limit used (0-100, null for unlimited tiers)
             */
            percentage_used?: number;
            /**
             * @description Whether the customer can make more requests
             * @enum {string}
             */
            state: "allowed" | "exhausted";
        };
        CustomerMeUsageResponse: {
            usage: components["schemas"]["CustomerMeUsage"];
        };
        CustomerCreate: {
            /** Format: uuid */
            tier_id: string;
            /** @description External customer identifier from your system */
            external_id: string;
            /**
             * Format: email
             * @description Customer email address
             */
            email?: string;
            metadata?: {
                [key: string]: unknown;
            };
        };
        /** @enum {string} */
        MessageRole: "system" | "user" | "assistant" | "tool";
        ContentPart: {
            /** @enum {string} */
            type: "text";
            text?: string;
        };
        InputItem: {
            /** @enum {string} */
            type: "message";
            role?: components["schemas"]["MessageRole"];
            content?: components["schemas"]["ContentPart"][];
            tool_calls?: components["schemas"]["ToolCall"][];
            tool_call_id?: string;
        };
        OutputItem: {
            /** @enum {string} */
            type: "message";
            role?: components["schemas"]["MessageRole"];
            content?: components["schemas"]["ContentPart"][];
            tool_calls?: components["schemas"]["ToolCall"][];
        };
        JSONSchemaFormat: {
            name: string;
            description?: string;
            schema?: {
                [key: string]: unknown;
            };
            strict?: boolean;
        };
        OutputFormat: {
            /** @enum {string} */
            type: "text" | "json_schema";
            json_schema?: components["schemas"]["JSONSchemaFormat"];
        };
        Tool: {
            /** @enum {string} */
            type: "function" | "web" | "x_search" | "code_execution";
            function?: {
                name?: string;
                description?: string;
                parameters?: {
                    [key: string]: unknown;
                };
            };
            web?: {
                [key: string]: unknown;
            };
            x_search?: {
                [key: string]: unknown;
            };
            code_execution?: {
                [key: string]: unknown;
            };
        };
        ToolChoice: {
            /** @enum {string} */
            type: "auto" | "required" | "none";
            function?: string;
        };
        ResponsesRequest: {
            provider?: components["schemas"]["ProviderId"];
            model?: components["schemas"]["ModelId"];
            input: components["schemas"]["InputItem"][];
            output_format?: components["schemas"]["OutputFormat"];
            /** Format: uint32 */
            max_output_tokens?: number;
            temperature?: number;
            stop?: string[];
            tools?: components["schemas"]["Tool"][];
            tool_choice?: components["schemas"]["ToolChoice"];
        };
        ResponsesResponse: {
            /** @description Response identifier from the provider */
            id: string;
            output: components["schemas"]["OutputItem"][];
            model: components["schemas"]["ModelId"];
            provider?: components["schemas"]["ProviderId"];
            /** @description Why generation stopped (stop, max_tokens, tool_use, etc.) */
            stop_reason?: string;
            usage: components["schemas"]["Usage"];
            /** @description Sources from web search results */
            citations?: components["schemas"]["Citation"][];
        };
        ResponsesStreamEnvelope: {
            /** @enum {string} */
            type: "start" | "update" | "completion" | "error" | "keepalive" | "tool_use_start" | "tool_use_delta" | "tool_use_stop";
            payload?: {
                [key: string]: unknown;
            };
            complete_fields?: string[];
            code?: string;
            message?: string;
            status?: number;
            request_id?: string;
            provider?: components["schemas"]["ProviderId"];
            model?: components["schemas"]["ModelId"];
            stop_reason?: string;
            usage?: components["schemas"]["Usage"];
        };
        ResponsesBatchRequest: {
            requests: components["schemas"]["ResponsesRequest"][];
            options?: {
                /** Format: uint32 */
                max_parallelism?: number;
                abort_on_error?: boolean;
            };
        };
        ResponsesBatchError: {
            status: number;
            message: string;
            /** @description Raw error details from the provider */
            detail?: string;
            code?: string;
        };
        ResponsesBatchResult: {
            /** Format: uint32 */
            index: number;
            ok: boolean;
            response?: components["schemas"]["ResponsesResponse"];
            error?: components["schemas"]["ResponsesBatchError"];
        };
        ResponsesBatchResponse: {
            results: components["schemas"]["ResponsesBatchResult"][];
            request_id?: string;
        };
        /** @description A `workflow.v0` spec. The canonical JSON Schema is available at `/schemas/workflow_v0.schema.json`. */
        WorkflowSpecV0: {
            [key: string]: unknown;
        };
        RunsCreateOptionsV0: {
            idempotency_key?: string;
        };
        RunsCreateRequest: {
            spec: components["schemas"]["WorkflowSpecV0"];
            /** @description Reserved for future use. */
            input?: {
                [key: string]: unknown;
            };
            options?: components["schemas"]["RunsCreateOptionsV0"];
        };
        /** @enum {string} */
        RunStatusV0: "running" | "waiting" | "succeeded" | "failed" | "canceled";
        RunsCreateResponse: {
            run_id: components["schemas"]["RunId"];
            status: components["schemas"]["RunStatusV0"];
            plan_hash: components["schemas"]["PlanHash"];
        };
        /** @enum {string} */
        NodeStatusV0: "pending" | "running" | "waiting" | "succeeded" | "failed" | "canceled";
        NodeErrorV0: {
            code?: string;
            message: string;
            /** @description Raw error details from the provider */
            detail?: string;
        };
        NodeResultV0: {
            id: components["schemas"]["NodeId"];
            type: components["schemas"]["NodeTypeV0"];
            status: components["schemas"]["NodeStatusV0"];
            /** Format: date-time */
            started_at?: string;
            /** Format: date-time */
            ended_at?: string;
            output?: {
                [key: string]: unknown;
            };
            error?: components["schemas"]["NodeErrorV0"];
        };
        RunCostLineItemV0: {
            provider_id: components["schemas"]["ProviderId"];
            model: components["schemas"]["ModelId"];
            /** Format: uint64 */
            requests: number;
            /** Format: uint64 */
            input_tokens: number;
            /** Format: uint64 */
            output_tokens: number;
            /** Format: uint64 */
            usd_cents: number;
        };
        RunCostSummaryV0: {
            /** Format: uint64 */
            total_usd_cents: number;
            line_items?: components["schemas"]["RunCostLineItemV0"][];
        };
        RunsGetResponse: {
            run_id: components["schemas"]["RunId"];
            status: components["schemas"]["RunStatusV0"];
            plan_hash: components["schemas"]["PlanHash"];
            cost_summary: components["schemas"]["RunCostSummaryV0"];
            nodes?: components["schemas"]["NodeResultV0"][];
            outputs?: {
                [key: string]: unknown;
            };
        };
        /** @description Token usage statistics. All fields default to 0 if not present. */
        Usage: {
            /**
             * Format: uint64
             * @default 0
             */
            input_tokens: number;
            /**
             * Format: uint64
             * @default 0
             */
            output_tokens: number;
            /**
             * Format: uint64
             * @default 0
             */
            total_tokens: number;
        };
        ToolCall: {
            id: string;
            /** @enum {string} */
            type: "function" | "web" | "x_search" | "code_execution";
            function?: {
                name?: string;
                /** @description JSON string of function arguments */
                arguments?: string;
            };
        };
        Citation: {
            url?: string;
            title?: string;
        };
        CustomerTokenResponse: {
            /** @description The customer bearer token */
            token: string;
            /**
             * Format: date-time
             * @description Token expiration timestamp
             */
            expires_at: string;
            /**
             * Format: uint32
             * @description Seconds until token expires
             */
            expires_in: number;
            /**
             * Format: uuid
             * @description Project the token is scoped to
             */
            project_id: string;
            /**
             * Format: uuid
             * @description Internal customer UUID
             */
            customer_id: string;
            /** @description External customer identifier */
            customer_external_id: string;
            tier_code: components["schemas"]["TierCode"];
        };
        DeviceStartResponse: {
            /** @description Device code used for polling /auth/device/token */
            device_code: string;
            /** @description Human-enterable code shown to the user */
            user_code: string;
            /** @description URL where the user enters the code and completes authorization */
            verification_uri: string;
            /** @description Convenience URL that pre-fills the user_code (optional) */
            verification_uri_complete?: string;
            /**
             * Format: uint32
             * @description Seconds until the device code expires
             */
            expires_in: number;
            /**
             * Format: uint32
             * @description Minimum polling interval in seconds
             */
            interval: number;
        };
        DeviceTokenError: {
            /** @description OAuth device flow error code */
            error: string;
            /** @description Optional human-readable error message */
            error_description?: string;
            /**
             * Format: uint32
             * @description Updated recommended polling interval in seconds (when error is slow_down)
             */
            interval?: number;
        };
        APIError: {
            error: string;
            code: string;
            message: string;
        };
        /** @description Subscription status for a customer. */
        SubscriptionStatus: {
            /** @description Whether the subscription is currently active */
            active: boolean;
            /** @description Stripe subscription ID */
            subscription_id?: string;
            /** @description Subscription status (active, past_due, canceled, etc.) */
            status?: string;
            /**
             * Format: date-time
             * @description Start of the current billing period
             */
            current_period_start?: string;
            /**
             * Format: date-time
             * @description End of the current billing period
             */
            current_period_end?: string;
        };
        /** @description Response containing pending tool calls for a workflow run. */
        RunsPendingToolsResponse: {
            run_id: components["schemas"]["RunId"];
            pending?: components["schemas"]["RunsPendingToolsNodeV0"][];
        };
        /** @description A node with pending tool calls. */
        RunsPendingToolsNodeV0: {
            node_id: components["schemas"]["NodeId"];
            /**
             * Format: uint64
             * @description The step number within the node execution
             */
            step: number;
            request_id: components["schemas"]["RequestId"];
            tool_calls?: components["schemas"]["RunsPendingToolCallV0"][];
        };
        /** @description A pending tool call waiting for a result. */
        RunsPendingToolCallV0: {
            /** @description Unique identifier for this tool call */
            tool_call_id: string;
            /** @description Name of the tool to be called */
            name: string;
            /** @description JSON-encoded arguments for the tool call */
            arguments: string;
        };
        /**
         * @description Events sent during streaming responses (application/x-ndjson).
         *     Each line is a JSON object with an "event" field indicating the type.
         */
        NDJSONStreamEvent: {
            /**
             * @description Event type
             * @enum {string}
             */
            event: "message_start" | "message_delta" | "message_stop" | "tool_use_start" | "tool_use_delta" | "tool_use_stop" | "ping" | "keepalive";
            /** @description Response identifier (message_start) */
            response_id?: string;
            model?: components["schemas"]["ModelId"];
            /** @description Text content fragment (message_delta) */
            text_delta?: string;
            /** @description Why generation stopped (message_stop) */
            stop_reason?: string;
            usage?: components["schemas"]["Usage"];
            /** @description Completed tool calls (tool_use_stop, message_stop) */
            tool_calls?: components["schemas"]["ToolCall"][];
            tool_call_delta?: components["schemas"]["ToolCallDelta"];
        };
        /** @description Incremental tool call data during streaming */
        ToolCallDelta: {
            /** Format: uint32 */
            index?: number;
            id?: string;
            type?: string;
            function?: {
                name?: string;
                /** @description Partial JSON string */
                arguments?: string;
            };
        };
        /** @description Workflow node identifier. Must start with a lowercase letter and contain only lowercase letters, numbers, and underscores. */
        NodeId: string;
        /** @description LLM model identifier (e.g., claude-sonnet-4-20250514, gpt-4o). */
        ModelId: string;
        /**
         * @description Workflow-critical model capability identifier.
         * @enum {string}
         */
        ModelCapability: "tools" | "vision" | "web_search" | "computer_use" | "code_execution";
        Model: {
            model_id: components["schemas"]["ModelId"];
            provider: components["schemas"]["ProviderId"];
            display_name: string;
            description: string;
            capabilities: components["schemas"]["ModelCapability"][];
            /** Format: int32 */
            context_window: number;
            /** Format: int32 */
            max_output_tokens: number;
            /** @description Training cutoff in YYYY-MM format */
            training_cutoff: string;
            deprecated: boolean;
            deprecation_message: string;
            /** Format: uint64 */
            input_cost_per_million_cents: number;
            /** Format: uint64 */
            output_cost_per_million_cents: number;
        };
        ModelsResponse: {
            models: components["schemas"]["Model"][];
        };
        /**
         * Format: uuid
         * @description Unique identifier for a workflow run.
         */
        RunId: string;
        /**
         * Format: uuid
         * @description Unique identifier for an LLM request within a workflow run.
         */
        RequestId: string;
        /** @description SHA-256 hash of the compiled workflow plan (64 hex characters). */
        PlanHash: string;
        /** @description SHA-256 hash (64 hex characters). */
        Sha256Hash: string;
        /**
         * @description LLM provider identifier.
         * @enum {string}
         */
        ProviderId: "anthropic" | "openai" | "xai" | "google-ai-studio";
        PluginsLoadRequest: {
            /** @description GitHub URL for the plugin root (or a file within the plugin). */
            source_url: string;
        };
        PluginsRunRequest: {
            /** @description GitHub URL for the plugin root (or a file within the plugin). */
            source_url: string;
            /** @description Plugin command name (from commands/*.md). */
            command: string;
            /** @description User task/prompt for the plugin. */
            user_task: string;
            /** @description Execution model override for workflow llm.responses nodes. Optional for customer-attributed requests. */
            model?: components["schemas"]["ModelId"];
            /** @description Model used for pluginâ†’workflow conversion. Defaults server-side when omitted. */
            converter_model?: components["schemas"]["ModelId"];
            /** @description Optional idempotency key for run creation. */
            idempotency_key?: string;
        };
        PluginManifestV0: {
            name?: string;
            description?: string;
            version?: string;
            commands?: string[];
            agents?: string[];
        };
        PluginGitHubRefV0: {
            owner?: string;
            repo?: string;
            ref?: string;
            path?: string;
        };
        PluginCommandV0: {
            name: string;
            prompt: string;
            agent_refs?: string[];
        };
        PluginAgentV0: {
            name: string;
            system_prompt: string;
        };
        PluginsLoadResponseV0: {
            /** @description Stable plugin identifier (owner/repo/path). */
            id: string;
            /** @description Canonical plugin URL (github.com/owner/repo@ref/path). */
            url: string;
            manifest: components["schemas"]["PluginManifestV0"];
            commands: {
                [key: string]: components["schemas"]["PluginCommandV0"];
            };
            agents: {
                [key: string]: components["schemas"]["PluginAgentV0"];
            };
            raw_files: {
                [key: string]: string;
            };
            ref: components["schemas"]["PluginGitHubRefV0"];
            /** Format: date-time */
            loaded_at: string;
        };
        PluginsRunResponseV0: {
            plugin_id: string;
            plugin_url: string;
            run_id: components["schemas"]["RunId"];
            status: components["schemas"]["RunStatusV0"];
            plan_hash: components["schemas"]["PlanHash"];
            conversion_model?: components["schemas"]["ModelId"];
            conversion_response_id?: string;
            conversion_usage?: components["schemas"]["Usage"];
        };
        /**
         * @description Type of workflow node.
         * @enum {string}
         */
        NodeTypeV0: "llm.responses" | "join.all" | "transform.json";
        /** @description Tier code identifier (e.g., free, pro, enterprise). */
        TierCode: string;
    };
    responses: never;
    parameters: {
        ProjectID: string;
    };
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
    getWorkflowV0Schema: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Schema document */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/schema+json": Record<string, never>;
                };
            };
        };
    };
    getRunEventV0Schema: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Schema document */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/schema+json": Record<string, never>;
                };
            };
        };
    };
    registerOwner: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /** Format: email */
                    email?: string;
                    password?: string;
                };
            };
        };
        responses: {
            /** @description User created */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AuthResponse"];
                };
            };
        };
    };
    login: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /** Format: email */
                    email?: string;
                    password?: string;
                };
            };
        };
        responses: {
            /** @description Tokens issued */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AuthResponse"];
                };
            };
        };
    };
    refreshToken: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    refresh_token?: string;
                };
            };
        };
        responses: {
            /** @description Tokens refreshed */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AuthTokens"];
                };
            };
        };
    };
    logout: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    refresh_token?: string;
                };
            };
        };
        responses: {
            /** @description Session revoked */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getAuthenticatedUser: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Current user */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        user?: components["schemas"]["User"];
                    };
                };
            };
        };
    };
    mintCustomerToken: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /**
                     * Format: uuid
                     * @description Project ID the customer belongs to
                     */
                    project_id: string;
                    /**
                     * Format: uuid
                     * @description Internal customer UUID (provide exactly one of customer_id or customer_external_id)
                     */
                    customer_id?: string;
                    /** @description External customer identifier (provide exactly one of customer_id or customer_external_id) */
                    customer_external_id?: string;
                    /**
                     * Format: uint32
                     * @description Requested token TTL in seconds (server may cap this)
                     */
                    ttl_seconds?: number;
                };
            };
        };
        responses: {
            /** @description Customer token issued */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CustomerTokenResponse"];
                };
            };
            /** @description Invalid request (missing or invalid customer selector) */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Invalid or missing secret key */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Customer not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    startDeviceAuthorization: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Device authorization session started */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DeviceStartResponse"];
                };
            };
            /** @description Invalid request (e.g., missing project-scoped API key) */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Missing or invalid API key */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    pollDeviceToken: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /** @description Opaque device code returned by /auth/device/start */
                    device_code: string;
                };
            };
        };
        responses: {
            /** @description Customer token issued */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CustomerTokenResponse"];
                };
            };
            /** @description OAuth device flow error (authorization_pending, slow_down, expired_token, invalid_grant, access_denied) */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DeviceTokenError"];
                };
            };
            /** @description Missing or invalid API key */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    exchangeOidcToken: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /** @description OIDC id_token JWT to verify and exchange */
                    id_token: string;
                    /**
                     * Format: uuid
                     * @description Optional; must match the API key's project_id if provided
                     */
                    project_id?: string;
                };
            };
        };
        responses: {
            /** @description Customer token issued */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CustomerTokenResponse"];
                };
            };
            /** @description Invalid request or token contents */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["APIError"];
                };
            };
            /** @description Invalid id_token */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Identity unknown and auto-provision disabled */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["APIError"];
                };
            };
            /** @description Identity already linked to a different customer */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    claimCustomer: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /** Format: email */
                    email: string;
                    /**
                     * @description Identity provider (must match project's enabled providers)
                     * @enum {string}
                     */
                    provider: "github" | "google" | "oidc";
                    /** @description OAuth/OIDC subject claim from the identity provider */
                    subject: string;
                };
            };
        };
        responses: {
            /** @description Customer identity linked */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        customer?: components["schemas"]["Customer"];
                    };
                };
            };
            /** @description Customer not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Identity already linked to a different customer */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getCustomerMe: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Customer details */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CustomerMeResponse"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getCustomerMeUsage: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Usage summary */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CustomerMeUsageResponse"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    listModels: {
        parameters: {
            query?: {
                /** @description Filter results to a specific provider */
                provider?: components["schemas"]["ProviderId"];
                /** @description Filter results to models that support a capability */
                capability?: components["schemas"]["ModelCapability"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Models list */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ModelsResponse"];
                };
            };
        };
    };
    handleBillingWebhook: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Event accepted */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    listProjects: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Project list */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        projects?: components["schemas"]["Project"][];
                    };
                };
            };
        };
    };
    createProject: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    name?: string;
                    description?: string;
                };
            };
        };
        responses: {
            /** @description Project created */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        project?: components["schemas"]["Project"];
                    };
                };
            };
        };
    };
    getProject: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                id: components["parameters"]["ProjectID"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Project found */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        project?: components["schemas"]["Project"];
                    };
                };
            };
        };
    };
    updateProject: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                id: components["parameters"]["ProjectID"];
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    name?: string;
                    description?: string;
                    /** Format: uuid */
                    customer_auto_provision_tier_id?: string;
                    customer_oauth_providers?: ("github" | "google")[];
                    oidc_enabled?: boolean;
                    oidc_issuer?: string;
                    oidc_audiences?: string[];
                    oidc_jwks_url?: string;
                    oidc_subject_claim?: string;
                };
            };
        };
        responses: {
            /** @description Project updated */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        project?: components["schemas"]["Project"];
                    };
                };
            };
        };
    };
    deleteProject: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                id: components["parameters"]["ProjectID"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Project deleted */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    listProjectTiers: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                id: components["parameters"]["ProjectID"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Tier list */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        tiers?: components["schemas"]["Tier"][];
                    };
                };
            };
        };
    };
    createTier: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                id: components["parameters"]["ProjectID"];
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["TierCreate"];
            };
        };
        responses: {
            /** @description Tier created */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        tier?: components["schemas"]["Tier"];
                    };
                };
            };
        };
    };
    updateTier: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                id: components["parameters"]["ProjectID"];
                tier_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["TierUpdate"];
            };
        };
        responses: {
            /** @description Tier updated */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    deleteTier: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                id: components["parameters"]["ProjectID"];
                tier_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Tier deleted */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    listProjectCustomers: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                id: components["parameters"]["ProjectID"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Customer list */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        customers?: components["schemas"]["Customer"][];
                    };
                };
            };
        };
    };
    createCustomer: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                id: components["parameters"]["ProjectID"];
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CustomerCreate"];
            };
        };
        responses: {
            /** @description Customer created */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        customer?: components["schemas"]["Customer"];
                    };
                };
            };
        };
    };
    updateCustomer: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                id: components["parameters"]["ProjectID"];
                customer_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CustomerCreate"];
            };
        };
        responses: {
            /** @description Customer updated */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    deleteCustomer: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                id: components["parameters"]["ProjectID"];
                customer_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Customer deleted */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    createResponse: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ResponsesRequest"];
            };
        };
        responses: {
            /** @description Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResponsesResponse"];
                };
            };
        };
    };
    createResponsesBatch: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ResponsesBatchRequest"];
            };
        };
        responses: {
            /** @description Batch response results */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResponsesBatchResponse"];
                };
            };
        };
    };
    pluginsLoad: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["PluginsLoadRequest"];
            };
        };
        responses: {
            /** @description Plugin loaded */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PluginsLoadResponseV0"];
                };
            };
        };
    };
    pluginsRun: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["PluginsRunRequest"];
            };
        };
        responses: {
            /** @description Run created (or idempotent replay) */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PluginsRunResponseV0"];
                };
            };
        };
    };
    createRun: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["RunsCreateRequest"];
            };
        };
        responses: {
            /** @description Run created (or idempotent replay) */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RunsCreateResponse"];
                };
            };
        };
    };
    getRun: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                run_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Run snapshot */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RunsGetResponse"];
                };
            };
            /** @description Run not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    streamRunEvents: {
        parameters: {
            query?: {
                /** @description Returns events where `seq > after_seq`. */
                after_seq?: number;
                /** @description When false, returns currently available events then closes. */
                wait?: boolean;
                /** @description Maximum number of events to send before closing. */
                limit?: number;
            };
            header?: never;
            path: {
                run_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Event stream (NDJSON or SSE) */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    /**
                     * @example {"envelope_version":"v0","seq":1,"type":"run_compiled",...}
                     *     {"envelope_version":"v0","seq":2,"type":"run_started",...}
                     */
                    "application/x-ndjson": string;
                    /**
                     * @example event: run_started
                     *     id: 2
                     *     data: {"envelope_version":"v0","seq":2,"type":"run_started",...}
                     */
                    "text/event-stream": string;
                };
            };
        };
    };
}
